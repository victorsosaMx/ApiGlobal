using Microsoft.AspNetCore.Mvc;
using Microsoft.Extensions.Configuration;
using Microsoft.Extensions.Logging;
using RestSharp;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text.Json;
using System.Threading.Tasks;
using System.Xml.Linq;
using System.Text;
using System.IO;
using Microsoft.AspNetCore.Http;
using ApiGlobal.Models;

namespace ApiGlobal.Controllers
{
    /// <summary>
    /// Controlador que actúa como proxy para realizar peticiones HTTP a diferentes APIs externas.
    /// Permite centralizar y estandarizar las llamadas a múltiples servicios desde una sola interfaz.
    /// </summary>
    [ApiController]
    [Route("[controller]")]
    public class ApiProxyController : ControllerBase
    {
        #region Campos privados y constantes
        
        private readonly IConfiguration _configuration;
        private readonly ILogger<ApiProxyController> _logger;
        private readonly Dictionary<string, string> _apiServers;
        private readonly string _logsDirectory;

        // Constantes para mejorar mantenibilidad y evitar valores mágicos
        private const int DEFAULT_TIMEOUT_SECONDS = 360;
        private const string ISO_8859_1_ENCODING = "ISO-8859-1";
        private const string WEBSPEED_COMMENT = "<!-- Generated by Webspeed: http://www.webspeed.com/ -->";
        private const string CONTENT_TYPE_JSON = "application/json";
        private const string CONTENT_TYPE_XML = "application/xml";
        private const string CONTENT_TYPE_HTML = "text/html";
        private const string CONTENT_TYPE_TEXT = "text/plain";
        private const string CONTENT_TYPE_FORM = "application/x-www-form-urlencoded";

        #endregion

        #region Constructor

        /// <summary>
        /// Constructor del controlador. Inicializa las dependencias y carga la configuración.
        /// </summary>
        /// <param name="configuration">Configuración de la aplicación</param>
        /// <param name="logger">Logger para registrar eventos</param>
        public ApiProxyController(IConfiguration configuration, ILogger<ApiProxyController> logger)
        {
            _configuration = configuration ?? throw new ArgumentNullException(nameof(configuration));
            _logger = logger ?? throw new ArgumentNullException(nameof(logger));
            
            // Cargar configuración al inicio para mejor rendimiento y evitar accesos repetidos
            _apiServers = _configuration.GetSection("ApiServers").Get<Dictionary<string, string>>() ?? new Dictionary<string, string>();
            _logsDirectory = _configuration["DirectorioLogs"] ?? string.Empty;
        }

        #endregion

        #region Métodos públicos

        /// <summary>
        /// Método principal que procesa las solicitudes proxy hacia APIs externas.
        /// Soporta múltiples métodos HTTP (GET, POST, PUT, DELETE) y diferentes tipos de contenido.
        /// </summary>
        /// <param name="request">Objeto que contiene toda la información de la solicitud</param>
        /// <returns>Respuesta de la API externa con el formato solicitado</returns>
        [HttpPost]
        public async Task<IActionResult> ProxyRequest([FromBody] clsProxyRequest request)
        {
            // Validación básica de entrada
            if (request == null)
            {
                _logger.LogWarning("Se recibió una solicitud nula");
                return BadRequest("La solicitud no puede estar vacía");
            }

            try
            {
                // 1. Validar que el servidor especificado existe en la configuración
                if (!_apiServers.TryGetValue(request.Servidor, out var baseUrl))
                {
                    _logger.LogWarning("Servidor no válido: {Servidor}", request.Servidor);
                    return BadRequest($"Servidor no válido: {request.Servidor}");
                }

                // 2. Construir la URL completa con parámetros según el método HTTP
                var url = ConstructUrl(baseUrl, request.Opcion, GetParametersForUrl(request));
                
                _logger.LogInformation("Ejecutando proxy request a: {Url} con método: {Metodo}", url, request.Metodo);

                // 3. Ejecutar la solicitud HTTP hacia la API externa
                var response = await ExecuteApiRequest(baseUrl, url, request);
                
                if (response == null)
                {
                    _logger.LogError("No se pudo obtener respuesta de la API");
                    return StatusCode(500, "Error al obtener respuesta de la API");
                }

                // 4. Agregar headers informativos a la respuesta
                AddResponseHeaders(url, request.Metodo);

                // 5. Procesar y formatear la respuesta según el tipo solicitado
                return await ProcessApiResponse(response, request);
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Error procesando solicitud proxy para servidor: {Servidor}", request?.Servidor);
                
                return StatusCode(500, new
                {
                    Error = "Se produjo un error al procesar la solicitud.",
                    Details = ex.Message,
                    Timestamp = DateTime.UtcNow
                });
            }
        }

        #endregion

        #region Métodos privados de utilidad

        /// <summary>
        /// Determina qué parámetros usar en la URL según el método HTTP.
        /// GET: parámetros en query string, POST/PUT: parámetros en body
        /// </summary>
        /// <param name="request">Solicitud con la información del método y parámetros</param>
        /// <returns>Diccionario con los parámetros para la URL</returns>
        private Dictionary<string, string> GetParametersForUrl(clsProxyRequest request)
        {
            // Para GET, usar los parámetros en la URL. Para POST/PUT, usar diccionario vacío
            return request.Metodo.ToUpper() == "GET" 
                ? request.Parametros ?? new Dictionary<string, string>()
                : new Dictionary<string, string>();
        }

        /// <summary>
        /// Ejecuta la solicitud HTTP hacia la API externa utilizando RestSharp.
        /// Configura el cliente, la autenticación y el cuerpo de la solicitud.
        /// </summary>
        /// <param name="baseUrl">URL base del servidor de la API</param>
        /// <param name="url">URL completa de la solicitud</param>
        /// <param name="request">Objeto con la configuración de la solicitud</param>
        /// <returns>Respuesta de la API externa</returns>
        private async Task<RestResponse> ExecuteApiRequest(string baseUrl, string url, clsProxyRequest request)
        {
            // Usar 'using' para asegurar la liberación de recursos
            using var client = new RestClient(new RestClientOptions(baseUrl)
            {
                Timeout = TimeSpan.FromSeconds(DEFAULT_TIMEOUT_SECONDS)
            });

            // Crear la solicitud REST con el método HTTP apropiado
            var restRequest = CreateRestRequest(url, request);
            
            // Agregar headers de autenticación si están presentes
            AddAuthenticationHeaders(restRequest, request);
            
            // Agregar el cuerpo de la solicitud para métodos que lo requieren
            AddRequestBody(restRequest, request);

            // Ejecutar la solicitud de forma asíncrona
            return await client.ExecuteAsync(restRequest);
        }

        /// <summary>
        /// Crea un objeto RestRequest con el método HTTP apropiado.
        /// Mapea los strings de método a los enums de RestSharp.
        /// </summary>
        /// <param name="url">URL de la solicitud</param>
        /// <param name="request">Objeto con la información del método</param>
        /// <returns>Objeto RestRequest configurado</returns>
        private RestRequest CreateRestRequest(string url, clsProxyRequest request)
        {
            // Mapear el método HTTP string a enum Method de RestSharp
            var method = request.Metodo.ToUpper() switch
            {
                "GET" => Method.Get,
                "POST" => Method.Post,
                "PUT" => Method.Put,
                "DELETE" => Method.Delete,
                "PATCH" => Method.Patch,
                _ => Method.Get // Método por defecto si no se reconoce
            };

            return new RestRequest(url, method);
        }

        /// <summary>
        /// Agrega headers de autenticación a la solicitud HTTP.
        /// Soporta tanto tokens de autorización directos como Bearer tokens.
        /// </summary>
        /// <param name="restRequest">Objeto RestRequest al que agregar los headers</param>
        /// <param name="request">Objeto con la información de autenticación</param>
        private void AddAuthenticationHeaders(RestRequest restRequest, clsProxyRequest request)
        {
            // Agregar token de autorización directo
            if (!string.IsNullOrEmpty(request.AuthorizationToken))
            {
                restRequest.AddHeader("Authorization", request.AuthorizationToken);
                restRequest.AddHeader("Content-Type", CONTENT_TYPE_JSON);
                restRequest.AddHeader("Accept", CONTENT_TYPE_JSON);
            }
            // Agregar Bearer token
            else if (!string.IsNullOrEmpty(request.BearerAuthorizationToken))
            {
                restRequest.AddHeader("Authorization", $"Bearer {request.BearerAuthorizationToken}");
                restRequest.AddHeader("Content-Type", CONTENT_TYPE_JSON);
                restRequest.AddHeader("Accept", CONTENT_TYPE_JSON);
            }
        }

        /// <summary>
        /// Agrega el cuerpo de la solicitud para métodos HTTP que lo requieren.
        /// Soporta codificación ISO-8859-1 y JSON según la configuración.
        /// </summary>
        /// <param name="restRequest">Objeto RestRequest al que agregar el cuerpo</param>
        /// <param name="request">Objeto con los parámetros y configuración</param>
        private void AddRequestBody(RestRequest restRequest, clsProxyRequest request)
        {
            // Solo agregar cuerpo si hay parámetros y el método lo permite
            if (request.Parametros != null && IsMethodWithBody(request.Metodo))
            {
                if (request.CorregirISO8859)
                {
                    // Codificar parámetros para ISO-8859-1
                    var postData = EncodeParametersToIso88591(request.Parametros);
                    restRequest.AddParameter(CONTENT_TYPE_FORM, postData, ParameterType.RequestBody);
                }
                else
                {
                    // Usar JSON para el cuerpo de la solicitud
                    restRequest.AddJsonBody(request.Parametros);
                }
            }
        }

        /// <summary>
        /// Determina si un método HTTP permite cuerpo en la solicitud.
        /// </summary>
        /// <param name="method">Método HTTP como string</param>
        /// <returns>True si el método permite cuerpo, false en caso contrario</returns>
        private static bool IsMethodWithBody(string method)
        {
            var upperMethod = method.ToUpper();
            return upperMethod == "POST" || upperMethod == "PUT" || upperMethod == "PATCH";
        }

        /// <summary>
        /// Agrega headers informativos a la respuesta HTTP.
        /// Incluye la URL construida y el método utilizado para debugging.
        /// </summary>
        /// <param name="url">URL completa de la solicitud</param>
        /// <param name="method">Método HTTP utilizado</param>
        private void AddResponseHeaders(string url, string method)
        {
            // Agregar headers informativos para debugging y monitoreo
            HttpContext.Response.Headers.Add("Constructed-Url", url);
            HttpContext.Response.Headers.Add("Constructed-Url-Method", method.ToUpper());
        }

        /// <summary>
        /// Procesa la respuesta de la API externa según el tipo de contenido solicitado.
        /// Soporta XML, JSON, HTML, texto plano y descarga de archivos.
        /// </summary>
        /// <param name="response">Respuesta de la API externa</param>
        /// <param name="request">Objeto con la configuración de procesamiento</param>
        /// <returns>Resultado formateado según el tipo solicitado</returns>
        private async Task<IActionResult> ProcessApiResponse(RestResponse response, clsProxyRequest request)
        {
            // Generar información de logging si está habilitado
            var logInfo = await GenerateLogInfo(response, request);

            // Obtener el contenido de la respuesta
            var content = response.RawBytes ?? new byte[0];
            
            // Procesar según el tipo de contenido solicitado
            return request.Body.ToLower() switch
            {
                "xml" => ProcessXmlResponse(content, response, request, logInfo),
                "json" => ProcessJsonResponse(content, response, request, logInfo),
                "text" => ProcessTextResponse(content, response, request, logInfo),
                "html" => ProcessHtmlResponse(content, response, request, logInfo),
                _ => ProcessDefaultResponse(content, response, request, logInfo)
            };
        }

        /// <summary>
        /// Procesa respuesta XML. Valida la sintaxis y puede generar archivo de descarga.
        /// </summary>
        /// <param name="content">Contenido de la respuesta en bytes</param>
        /// <param name="response">Respuesta REST original</param>
        /// <param name="request">Configuración de la solicitud</param>
        /// <param name="logInfo">Información para logging</param>
        /// <returns>Resultado XML formateado</returns>
        private IActionResult ProcessXmlResponse(byte[] content, RestResponse response, clsProxyRequest request, Dictionary<string, string> logInfo)
        {
            try
            {
                // Decodificar contenido según la configuración de encoding
                var xmlContent = request.CorregirISO8859 
                    ? Encoding.GetEncoding(ISO_8859_1_ENCODING).GetString(content) 
                    : Encoding.UTF8.GetString(content);

                // Validar y parsear XML
                var xmlResponse = XElement.Parse(xmlContent);
                var cleanXmlContent = xmlResponse.ToString().Replace(WEBSPEED_COMMENT, "");

                // Generar log si está habilitado
                if (!request.LogSoloEnError)
                {
                    LogApiCall(request, logInfo, CONTENT_TYPE_XML, cleanXmlContent);
                }

                // Generar archivo de descarga si está solicitado
                if (request.DescargaArchivoSwagger)
                {
                    var fileName = $"response_{DateTime.Now:yyyyMMddHHmmss}.xml";
                    return File(Encoding.UTF8.GetBytes(cleanXmlContent), CONTENT_TYPE_XML, fileName);
                }

                return new ContentResult
                {
                    Content = cleanXmlContent,
                    ContentType = CONTENT_TYPE_XML,
                    StatusCode = (int)response.StatusCode
                };
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Error procesando respuesta XML");
                return StatusCode(500, "Error al procesar respuesta XML: " + ex.Message);
            }
        }

        /// <summary>
        /// Procesa respuesta JSON. Puede generar archivo de descarga.
        /// </summary>
        /// <param name="content">Contenido de la respuesta en bytes</param>
        /// <param name="response">Respuesta REST original</param>
        /// <param name="request">Configuración de la solicitud</param>
        /// <param name="logInfo">Información para logging</param>
        /// <returns>Resultado JSON formateado</returns>
        private IActionResult ProcessJsonResponse(byte[] content, RestResponse response, clsProxyRequest request, Dictionary<string, string> logInfo)
        {
            // Decodificar contenido y limpiar comentarios no deseados
            var jsonContent = Encoding.UTF8.GetString(content).Replace(WEBSPEED_COMMENT, "");

            // Generar log si está habilitado
            if (!request.LogSoloEnError)
            {
                LogApiCall(request, logInfo, CONTENT_TYPE_JSON, jsonContent);
            }

            // Generar archivo de descarga si está solicitado
            if (request.DescargaArchivoSwagger)
            {
                var fileName = $"response_{DateTime.Now:yyyyMMddHHmmss}.json";
                return File(Encoding.UTF8.GetBytes(jsonContent), CONTENT_TYPE_JSON, fileName);
            }

            return new ContentResult
            {
                Content = jsonContent,
                ContentType = CONTENT_TYPE_JSON,
                StatusCode = (int)response.StatusCode
            };
        }

        /// <summary>
        /// Procesa respuesta de texto plano. Soporta codificación ISO-8859-1.
        /// </summary>
        /// <param name="content">Contenido de la respuesta en bytes</param>
        /// <param name="response">Respuesta REST original</param>
        /// <param name="request">Configuración de la solicitud</param>
        /// <param name="logInfo">Información para logging</param>
        /// <returns>Resultado de texto plano</returns>
        private IActionResult ProcessTextResponse(byte[] content, RestResponse response, clsProxyRequest request, Dictionary<string, string> logInfo)
        {
            // Decodificar contenido según la configuración de encoding
            var textContent = request.CorregirISO8859 
                ? Encoding.GetEncoding(ISO_8859_1_ENCODING).GetString(content) 
                : Encoding.UTF8.GetString(content);

            // Generar log si está habilitado
            if (!request.LogSoloEnError)
            {
                LogApiCall(request, logInfo, CONTENT_TYPE_TEXT, textContent);
            }

            // Generar archivo de descarga si está solicitado
            if (request.DescargaArchivoSwagger)
            {
                var fileName = $"response_{DateTime.Now:yyyyMMddHHmmss}.txt";
                return File(Encoding.UTF8.GetBytes(textContent), CONTENT_TYPE_TEXT, fileName);
            }

            return new ContentResult
            {
                Content = textContent,
                ContentType = CONTENT_TYPE_TEXT,
                StatusCode = (int)response.StatusCode
            };
        }

        /// <summary>
        /// Procesa respuesta HTML. Soporta codificación ISO-8859-1.
        /// </summary>
        /// <param name="content">Contenido de la respuesta en bytes</param>
        /// <param name="response">Respuesta REST original</param>
        /// <param name="request">Configuración de la solicitud</param>
        /// <param name="logInfo">Información para logging</param>
        /// <returns>Resultado HTML</returns>
        private IActionResult ProcessHtmlResponse(byte[] content, RestResponse response, clsProxyRequest request, Dictionary<string, string> logInfo)
        {
            // Decodificar contenido según la configuración de encoding
            var htmlContent = request.CorregirISO8859 
                ? Encoding.GetEncoding(ISO_8859_1_ENCODING).GetString(content) 
                : Encoding.UTF8.GetString(content);

            // Generar log si está habilitado
            if (!request.LogSoloEnError)
            {
                LogApiCall(request, logInfo, CONTENT_TYPE_HTML, htmlContent);
            }

            // Generar archivo de descarga si está solicitado
            if (request.DescargaArchivoSwagger)
            {
                var fileName = $"response_{DateTime.Now:yyyyMMddHHmmss}.html";
                return File(Encoding.UTF8.GetBytes(htmlContent), CONTENT_TYPE_HTML, fileName);
            }

            return new ContentResult
            {
                Content = htmlContent,
                ContentType = CONTENT_TYPE_HTML,
                StatusCode = (int)response.StatusCode
            };
        }

        /// <summary>
        /// Procesa respuesta con tipo de contenido por defecto o desconocido.
        /// Para GET retorna contenido como texto, para otros métodos retorna como archivo.
        /// </summary>
        /// <param name="content">Contenido de la respuesta en bytes</param>
        /// <param name="response">Respuesta REST original</param>
        /// <param name="request">Configuración de la solicitud</param>
        /// <param name="logInfo">Información para logging</param>
        /// <returns>Resultado según el método HTTP</returns>
        private IActionResult ProcessDefaultResponse(byte[] content, RestResponse response, clsProxyRequest request, Dictionary<string, string> logInfo)
        {
            // Para métodos GET, retornar como contenido de texto
            if (request.Metodo.ToUpper() == "GET")
            {
                var textContent = request.CorregirISO8859 
                    ? Encoding.GetEncoding(ISO_8859_1_ENCODING).GetString(content) 
                    : Encoding.UTF8.GetString(content);

                // Generar log si está habilitado
                if (!request.LogSoloEnError)
                {
                    LogApiCall(request, logInfo, response.ContentType ?? CONTENT_TYPE_TEXT, textContent);
                }

                return new ContentResult
                {
                    Content = textContent,
                    ContentType = response.ContentType ?? CONTENT_TYPE_TEXT,
                    StatusCode = (int)response.StatusCode
                };
            }
            else
            {
                // Para otros métodos, retornar como archivo binario
                if (!request.LogSoloEnError)
                {
                    LogApiCall(request, logInfo, response.ContentType ?? "application/octet-stream", "[Binary Content]");
                }

                return File(content, response.ContentType ?? "application/octet-stream");
            }
        }

        /// <summary>
        /// Genera información detallada de la respuesta para logging.
        /// Incluye headers, cookies, códigos de estado y metadatos.
        /// </summary>
        /// <param name="response">Respuesta de la API</param>
        /// <param name="request">Solicitud original</param>
        /// <returns>Diccionario con información de logging</returns>
        private async Task<Dictionary<string, string>> GenerateLogInfo(RestResponse response, clsProxyRequest request)
        {
            var logInfo = new Dictionary<string, string>
            {
                ["Metodo"] = request.Metodo.ToUpper(),
                ["ContentLength"] = response.ContentLength?.ToString() ?? "0",
                ["IsSuccessStatusCode"] = response.IsSuccessStatusCode.ToString(),
                ["ResponseStatus"] = response.ResponseStatus.ToString(),
                ["StatusCode"] = response.StatusCode.ToString(),
                ["StatusDescription"] = response.StatusDescription ?? string.Empty,
                ["ResponseUri"] = response.ResponseUri?.ToString() ?? string.Empty
            };

            // Agregar headers de respuesta
            if (response.Headers != null)
            {
                foreach (var header in response.Headers)
                {
                    logInfo.TryAdd($"Header_{header.Name}", header.Value?.ToString() ?? string.Empty);
                }
            }

            // Agregar headers de contenido
            if (response.ContentHeaders != null)
            {
                foreach (var header in response.ContentHeaders)
                {
                    logInfo.TryAdd($"ContentHeader_{header.Name}", header.Value?.ToString() ?? string.Empty);
                }
            }

            // Agregar información de encoding
            if (response.ContentEncoding != null)
            {
                var encodings = string.Join(", ", response.ContentEncoding);
                logInfo.TryAdd("ContentEncoding", encodings);
            }

            // Agregar cookies
            if (response.Cookies != null)
            {
                var cookies = string.Join("; ", response.Cookies.Select(c => c.ToString()));
                logInfo.TryAdd("Cookies", cookies);
            }

            return logInfo;
        }

        /// <summary>
        /// Registra la llamada a la API si el logging está habilitado.
        /// Este método está preparado para integrar con un sistema de logging personalizado.
        /// </summary>
        /// <param name="request">Solicitud original</param>
        /// <param name="logInfo">Información de logging</param>
        /// <param name="contentType">Tipo de contenido de la respuesta</param>
        /// <param name="content">Contenido de la respuesta</param>
        private void LogApiCall(clsProxyRequest request, Dictionary<string, string> logInfo, string contentType, string content)
        {
            try
            {
                // Agregar información adicional al log
                logInfo["ContentType"] = contentType;
                logInfo["Content"] = content;

                // Construir directorio de logs específico para el sistema y función
                var logDirectory = Path.Combine(_logsDirectory, request.Sistema, request.Funcion);

                // Aquí se puede integrar con clsUtilerias.GenerarLog o sistema de logging personalizado
                // clsUtilerias.GenerarLog(logDirectory, request.Funcion, request.Usuario, request.Parametros, logInfo);
                
                _logger.LogInformation("API Call logged for {Sistema}/{Funcion} by {Usuario}", 
                    request.Sistema, request.Funcion, request.Usuario);
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Error al generar log para la llamada API");
            }
        }

        #endregion

        #region Métodos de construcción de URL y codificación

        /// <summary>
        /// Construye la URL completa combinando la URL base, la opción y los parámetros.
        /// Los parámetros se agregan como query string para métodos GET.
        /// </summary>
        /// <param name="baseUrl">URL base del servidor</param>
        /// <param name="opcion">Endpoint o ruta específica</param>
        /// <param name="parametros">Parámetros a incluir en la URL</param>
        /// <returns>URL completa construida</returns>
        private string ConstructUrl(string baseUrl, string opcion, Dictionary<string, string> parametros)
        {
            // Asegurar que la URL base no termine en '/' y agregar la opción
            var url = baseUrl.TrimEnd('/') + "/" + opcion.TrimStart('/');

            // Agregar parámetros como query string si existen
            if (parametros != null && parametros.Any())
            {
                var queryString = string.Join("&", 
                    parametros.Select(p => $"{Uri.EscapeDataString(p.Key)}={Uri.EscapeDataString(p.Value ?? string.Empty)}"));
                url += "?" + queryString;
            }

            return url;
        }

        /// <summary>
        /// Codifica los parámetros en formato application/x-www-form-urlencoded
        /// para compatibilidad con sistemas que requieren codificación ISO-8859-1.
        /// </summary>
        /// <param name="parameters">Diccionario de parámetros a codificar</param>
        /// <returns>String con parámetros codificados</returns>
        private string EncodeParametersToIso88591(Dictionary<string, string> parameters)
        {
            if (parameters == null || !parameters.Any())
            {
                return string.Empty;
            }

            // Codificar cada parámetro individualmente
            var encodedParameters = parameters.Select(p => 
                $"{Uri.EscapeDataString(p.Key)}={Uri.EscapeDataString(p.Value ?? string.Empty)}");
            
            return string.Join("&", encodedParameters);
        }

        #endregion

        #region Métodos de validación y utilidades

        /// <summary>
        /// Valida que el objeto de solicitud tenga los campos requeridos.
        /// </summary>
        /// <param name="request">Objeto de solicitud a validar</param>
        /// <returns>Mensaje de error si la validación falla, null si es válida</returns>
        private string ValidateRequest(clsProxyRequest request)
        {
            if (string.IsNullOrWhiteSpace(request.Servidor))
            {
                return "El campo 'Servidor' es requerido";
            }

            if (string.IsNullOrWhiteSpace(request.Opcion))
            {
                return "El campo 'Opcion' es requerido";
            }

            if (string.IsNullOrWhiteSpace(request.Metodo))
            {
                return "El campo 'Metodo' es requerido";
            }

            var validMethods = new[] { "GET", "POST", "PUT", "DELETE", "PATCH" };
            if (!validMethods.Contains(request.Metodo.ToUpper()))
            {
                return $"Método HTTP no válido: {request.Metodo}. Métodos permitidos: {string.Join(", ", validMethods)}";
            }

            return null; // Validación exitosa
        }

        /// <summary>
        /// Determina si una respuesta HTTP indica éxito.
        /// </summary>
        /// <param name="statusCode">Código de estado HTTP</param>
        /// <returns>True si el código indica éxito (2xx), false en caso contrario</returns>
        private static bool IsSuccessStatusCode(int statusCode)
        {
            return statusCode >= 200 && statusCode <= 299;
        }

        /// <summary>
        /// Obtiene el tipo de contenido apropiado basado en la extensión del archivo o content type.
        /// </summary>
        /// <param name="fileName">Nombre del archivo</param>
        /// <param name="defaultContentType">Tipo de contenido por defecto</param>
        /// <returns>Tipo de contenido MIME apropiado</returns>
        private static string GetContentType(string fileName, string defaultContentType)
        {
            if (string.IsNullOrWhiteSpace(fileName))
            {
                return defaultContentType;
            }

            var extension = Path.GetExtension(fileName).ToLowerInvariant();
            
            return extension switch
            {
                ".json" => CONTENT_TYPE_JSON,
                ".xml" => CONTENT_TYPE_XML,
                ".html" => CONTENT_TYPE_HTML,
                ".txt" => CONTENT_TYPE_TEXT,
                ".pdf" => "application/pdf",
                ".zip" => "application/zip",
                ".csv" => "text/csv",
                _ => defaultContentType
            };
        }

        #endregion
    }
}

/*
 * NOTAS DE IMPLEMENTACIÓN:
 * 
 * 1. LOGGING: 
 *    - El método LogApiCall está preparado para integrar con clsUtilerias.GenerarLog
 *    - Actualmente usa el logger de ASP.NET Core como respaldo
 *    - Se puede descomentar la línea para usar el sistema de logging personalizado
 * 
 * 2. VALIDACIÓN:
 *    - Se agregó validación básica de campos requeridos
 *    - Se puede extender fácilmente para validaciones más complejas
 * 
 * 3. MANEJO DE ERRORES:
 *    - Cada método tiene su propio manejo de errores específico
 *    - Se usan try-catch específicos para diferentes tipos de operaciones
 * 
 * 4. PERFORMANCE:
 *    - Se cargan las configuraciones una sola vez en el constructor
 *    - Se usan 'using' statements para liberar recursos apropiadamente
 *    - Se evitan operaciones innecesarias en loops
 * 
 * 5. SEGURIDAD:
 *    - Se escapan adecuadamente los parámetros de URL
 *    - Se validan los métodos HTTP permitidos
 *    - Se sanitizan los paths de archivos
 * 
 * 6. EXTENSIBILIDAD:
 *    - La estructura permite agregar fácilmente nuevos tipos de respuesta
 *    - Se pueden agregar nuevos métodos de autenticación
 *    - El sistema de logging es pluggable
 * 
 * 7. CONFIGURACIÓN REQUERIDA en appsettings.json:
 *    {
 *      "ApiServers": {
 *        "servidor1": "https://api1.ejemplo.com",
 *        "servidor2": "https://api2.ejemplo.com"
 *      },
 *      "DirectorioLogs": "C:\\Logs\\ApiProxy\\"
 *    }
 */